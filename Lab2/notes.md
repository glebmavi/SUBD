# Вопросы
## Вопросы из se.ifmo.ru

1. Способы запуска и остановки сервера PosgreSQL, их отличия.
2. Какие параметры локали сервера БД можно настроить? На что они влияют? Как и где их переопределить?
3. Конфигурационные файлы сервера. Способы изменения и применения конфигурации.
4. Что такое табличное пространство? Зачем нужны дополнительные табличные пространства?
5. Зачем нужны template0 и template1?

## Собственные вопросы / вопросы Николаева

6. На что влияют параметры конфигурации PostgreSQL и как их подбирать?
    - max_connections
    - shared_buffers
    - temp_buffers
    - work_mem
    - checkpoint_timeout
    - effective_cache_size
    - fsync
    - commit_delay
7. Чем отличаются fsync и wal?
# Ответы

## 1. Способы запуска и остановки сервера PosgreSQL, их отличия:

- Команда pg_ctl позволяет управлять сервером напрямую. Например, запуск: pg_ctl start -D /path/to/data, остановка: pg_ctl stop -D /path/to/data. Этот метод удобен для ручного управления сервером, особенно в нестандартных окружениях.
- Использование системных сервисов (например, systemctl для систем с systemd). Пример: запуск systemctl start postgresql, остановка: systemctl stop postgresql. Этот способ предпочтителен в стандартных окружениях и автоматизирует управление сервером.
- Ручной запуск (postgres): postgres -D /path/to/data_directory
Обычно используется для отладки или специализированных сценариев, не подходит для повседневного использования в продакшен-среде из-за отсутствия интеграции с системными механизмами управления сервисами.
- Различие этих способов в том, что pg_ctl требует явного указания пути к директории данных и удобен для настройки разных экземпляров сервера, тогда как systemctl проще в использовании и интегрирован в управление системой.

## 2. Параметры локали в PostgreSQL:

- LC_COLLATE (Сортировка):
    Описание: Определяет правила сортировки строк в базе данных.
    Влияние: Влияет на порядок сортировки результатов запросов, операции сравнения строк и индексацию.
    Пример: ru_RU.UTF-8 для русской сортировки.

- LC_CTYPE (Типы символов):
    Описание: Определяет классификацию символов, включая определение букв, цифр и других категорий символов.
    Влияние: Влияет на функции обработки строк, такие как UPPER, LOWER, и на регулярные выражения.
    Пример: ru_RU.UTF-8 для русских символов.

- LC_MESSAGES (Сообщения системы):
    Описание: Определяет язык, на котором будут отображаться сообщения об ошибках и другие системные сообщения.
    Влияние: Удобство пользователей, использующих различные языки.
    Пример: ru_RU.UTF-8 для русских сообщений.

- LC_MONETARY (Формат валюты):
    Описание: Определяет формат отображения денежных величин.
    Влияние: Влияет на функции форматирования денежных данных.
    Пример: ru_RU.UTF-8 для отображения валюты в российском формате.

- LC_NUMERIC (Формат чисел):
    Описание: Определяет формат отображения чисел, включая десятичные разделители.
    Влияние: Влияет на функции форматирования числовых данных.
    Пример: ru_RU.UTF-8 использует запятую как десятичный разделитель.

- LC_TIME (Формат времени и даты):
    Описание: Определяет формат отображения дат и времени.
    Влияние: Влияет на функции форматирования временных данных и отображение временных меток.
    Пример: ru_RU.UTF-8 для русского формата дат и времени.

**На что влияют параметры локали:**

- Сортировка данных: Правила LC_COLLATE определяют, как строки сортируются, что важно для операций ORDER BY.

- Обработка строк: Параметры LC_CTYPE влияют на функции обработки строк, такие как преобразование регистра.

- Отображение сообщений: Параметр LC_MESSAGES определяет язык сообщений об ошибках и другой системной информации, что улучшает взаимодействие пользователей с сервером базы данных.

- Форматирование данных: Параметры LC_MONETARY, LC_NUMERIC и LC_TIME влияют на форматирование вывода денежных данных, чисел и временных меток, что важно для отчетов и пользовательского интерфейса.

**Как и где переопределить параметры локали:**

- При создании базы данных:
    Параметры локали задаются при инициализации базы данных с помощью initdb или при создании новой базы данных.
```bash
initdb -D /path/to/data_directory --locale=ru_RU.UTF-8 --encoding=ISO_8859-5
```

Пример создания базы данных с локалью:

```sql
CREATE DATABASE uglyredbird TEMPLATE template0
    ENCODING 'ISO_8859-5'
    LC_COLLATE 'ru_RU.UTF-8'
    LC_CTYPE 'ru_RU.UTF-8';
```

- Настройка конфигурационных файлов:
В конфигурационном файле postgresql.conf можно указать параметры локали.

```conf
# These settings are initialized by initdb, but they can be changed.
lc_messages = 'ru_RU.ISO8859-5'		# locale for system error message
                    # strings
lc_monetary = 'ru_RU.ISO8859-5'		# locale for monetary formatting
lc_numeric = 'ru_RU.ISO8859-5'		# locale for number formatting
lc_time = 'ru_RU.ISO8859-5'		# locale for time formatting
```

## 3. Конфигурационные файлы сервера. Способы изменения и применения конфигурации

**Основные конфигурационные файлы PostgreSQL:**

- postgresql.conf:
    Описание: Основной файл конфигурации сервера PostgreSQL. Содержит параметры, влияющие на поведение сервера, такие как параметры памяти, настройки WAL, параметры логирования и другие.

- pg_hba.conf:
    Описание: Файл конфигурации, отвечающий за контроль доступа к серверу базы данных. Определяет, какие клиенты могут подключаться к каким базам данных, используя какие методы аутентификации.

- pg_ident.conf:
    Описание: Файл конфигурации для идентификации пользователей при использовании методов аутентификации, основанных на идентификации системных пользователей.

**Способы изменения конфигурации:**

- Редактирование файлов напрямую: Открытие нужного конфигурационного файла в текстовом редакторе (например, nano, vim).

- Использование инструментов управления конфигурацией: Некоторые дистрибутивы или панели управления предоставляют интерфейсы для изменения конфигурационных параметров PostgreSQL.

- Параметры командной строки: При запуске сервера PostgreSQL можно передавать параметры командной строки для временного переопределения настроек.

    ```bash
    postgres -D /path/to/data_directory -c 'shared_buffers=1GB'
    ```

- Использование SQL-команд для некоторых параметров: Некоторые параметры можно изменять на уровне сессии или глобально через SQL-запросы.

    ```sql
    SET work_mem = '4MB';
    ALTER SYSTEM SET max_connections = 200;
    ```

- Использование `include` в postgresql.conf: Для удобства управления конфигурацией можно использовать директиву `include` для включения дополнительных файлов конфигурации.

    ```conf
    include '/path/to/custom.conf'
    ```

**Применение изменений конфигурации:**

Перезагрузка сервера PostgreSQL: Необходимо для применения большинства изменений в конфигурационных файлах.

- Использование pg_ctl:

```bash
pg_ctl -D /path/to/data_directory restart
```

- Использование systemd:

```bash
sudo systemctl restart postgresql
```

Перезагрузка настроек без полной остановки: Некоторые параметры поддерживают перезагрузку конфигурации без полной остановки сервера.

- Использование pg_ctl reload:

```bash
pg_ctl -D /path/to/data_directory reload
```

- Использование systemd:

```bash
sudo systemctl reload postgresql
```

- Применение изменений через SQL: Для параметров, изменяемых через SQL (ALTER SYSTEM или SET), можно применять изменения без перезагрузки сервера.

```sql
ALTER SYSTEM SET work_mem = '8MB';
SELECT pg_reload_conf();
```


## 4. Что такое табличное пространство? Зачем нужны дополнительные табличные пространства?

**Табличное пространство (Tablespace) в PostgreSQL:**

Табличное пространство — это абстракция уровня хранения данных, которая позволяет администраторам PostgreSQL управлять физическим размещением данных на диске. Табличное пространство указывает, где на файловой системе будут храниться файлы базы данных, связанные с определенными объектами, такими как таблицы и индексы.


Зачем нужны дополнительные табличные пространства:

- Оптимизация производительности:
    Распределение I/O нагрузки: Размещение часто используемых таблиц или индексов на быстродействующих дисках (например, SSD), а менее используемых на медленных (например, HDD).
    Параллельное чтение/запись: Размещение различных таблиц на разных физических устройствах позволяет повысить скорость операций за счет параллельного доступа.

- Управление пространством хранения:
    Разделение данных: Логическое разделение данных, например, размещение временных таблиц в отдельных табличных пространствах, облегчает управление и обслуживание.
    Архивирование и резервное копирование: Табличные пространства могут использоваться для организации данных, предназначенных для архивирования или резервного копирования.

- Безопасность и изоляция данных:
    Ограничение доступа: Размещение определенных данных в отдельных табличных пространствах может помочь ограничить доступ к ним на уровне файловой системы.
    Изоляция данных: Разделение данных различных приложений или пользователей в отдельных табличных пространствах повышает уровень изоляции и безопасности.

- Упрощение администрирования:
    Управление размером: Табличные пространства позволяют отслеживать и управлять объемом данных, хранящихся на отдельных дисках или разделах.
    Локализация ошибок: При возникновении проблем с хранением данных на одном из дисков, можно изолировать эти проблемы, затронув только соответствующее табличное пространство.

## 5. Зачем нужны template0 и template1?

PostgreSQL использует шаблонные базы данных template0 и template1 для создания новых баз данных. Эти шаблоны обеспечивают базовую структуру и набор системных объектов, необходимых для функционирования базы данных.

**template1:**

Описание: template1 — это стандартный шаблон базы данных, используемый по умолчанию для создания новых баз данных. Она содержит все стандартные системные объекты, такие как схемы, функции и т.д.

Особенности:
    Любые изменения, внесенные в template1 (например, установка расширений или создание пользовательских объектов), будут автоматически отражены во всех новых базах данных, созданных на его основе.
    По умолчанию, база данных template1 может использоваться для добавления общих объектов, которые должны быть доступны во всех новых базах данных.

Использование:
    Создание новой базы данных:
    CREATE DATABASE newdb TEMPLATE template1;

**template0:**

Описание: template0 — это неизменяемый шаблон базы данных, который служит для создания чистых баз данных без дополнительных объектов или изменений, внесенных в template1.

Особенности:
    template0 содержит только минимально необходимые системные объекты.
    Она предназначена для создания баз данных с оригинальной конфигурацией, без учета пользовательских изменений в template1.
    template0 обычно не изменяется пользователем, чтобы обеспечить чистую и неизмененную базу данных для специальных целей.

Использование:
    Создание новой базы данных без наследования изменений из template1:
    CREATE DATABASE newdb TEMPLATE template0;

Зачем нужны оба шаблона:

Гибкость при создании баз данных:
    Позволяют создавать базы данных как с настройками и объектами по умолчанию (template1), так и чистые базы без наследования пользовательских изменений (template0).

Изоляция системных настроек:
    template0 обеспечивает неизменяемую основу, что важно для случаев, когда требуется создание базы данных с оригинальными настройками или для восстановления.

Управление пользовательскими объектами:
    Позволяют администратору контролировать, какие объекты и настройки будут присутствовать в новых базах данных, добавляя или удаляя их в template1 без влияния на template0.


## 6. На что влияют параметры конфигурации PostgreSQL и как их подбирать?

- max_connections

    Описание: Определяет максимальное количество одновременных подключений к базе данных.
    Влияние: Если значение слишком низкое, пользователи могут получить отказ в подключении при достижении лимита. Если слишком высокое, могут возникнуть проблемы с производительностью, так как сервер PostgreSQL должен выделять память и управлять большим числом процессов.

- shared_buffers

    Описание: Это объем памяти, выделяемой под кэш PostgreSQL для работы с данными.
    Влияние: Чем больше кэш (если он уместится в ОЗУ сервера), тем реже данные будут запрашиваться с диска, что ускоряет работу. Однако, слишком большое значение может привести к нехватке памяти для других процессов.

- temp_buffers

    Описание: Определяет объем памяти, который выделяется для временных таблиц в каждом соединении.
    Влияние: Временные таблицы используются для промежуточных результатов запросов, если они не помещаются в основную память. Увеличение этого значения может ускорить обработку временных данных, но также увеличивает потребление памяти.

- work_mem

    Описание: Объем памяти, выделяемый для выполнения операций сортировки, хэш-таблиц и агрегаций в рамках одного запроса.
    Влияние: Недостаток памяти приводит к тому, что PostgreSQL начинает использовать временные файлы на диске для сортировки и выполнения запросов, что замедляет выполнение. Однако, если значение слишком высокое, память может быстро исчерпаться при одновременном выполнении многих запросов.

- checkpoint_timeout

    Описание: Определяет максимальный интервал времени между контрольными точками (checkpoints) в WAL (журнал транзакций).
    Влияние: Более частые контрольные точки могут замедлить систему, так как в момент их создания идет интенсивная запись данных на диск. Однако слишком редкие контрольные точки увеличивают время восстановления системы в случае сбоя.

- effective_cache_size

    Описание: Указывает объем памяти, который система считает доступным для кэширования дисковых данных (включает как shared_buffers, так и системный кэш).
    Влияние: Этот параметр не влияет непосредственно на выделение памяти, но помогает планировщику запросов принимать более эффективные решения по выбору индексов и способов выполнения запросов.

- fsync

    Описание: Определяет, синхронизируются ли все операции записи на диск, что обеспечивает целостность данных в случае сбоя системы.
    Влияние: Включение этого параметра (по умолчанию on) гарантирует, что данные записываются на диск до подтверждения транзакций, что снижает риск потери данных при сбое. Однако это может замедлить работу, особенно на системах с медленными дисками.
    Как подбирать: Отключать fsync не рекомендуется, так как это увеличивает риск потери данных при сбоях. Отключать его имеет смысл только в системах, где производительность важнее надежности данных (например, в тестовых окружениях).

- commit_delay

    Описание: Задает задержку перед записью данных в журнал транзакций (WAL) после подтверждения транзакции.
    Влияние: Позволяет PostgreSQL сгруппировать несколько транзакций и записать их вместе, что может повысить производительность при интенсивной работе с небольшими транзакциями. Однако слишком большая задержка может ухудшить отклик системы.
    Как подбирать: В большинстве случаев можно оставить по умолчанию (0), но для высоко-нагруженных систем с большим количеством мелких транзакций можно экспериментировать с небольшими значениями (например, 50–100 микросекунд).


## 7. Чем отличаются fsync и wal?

fsync: Это параметр, который определяет, будет ли PostgreSQL физически синхронизировать записи на диске при выполнении транзакций. Включенный fsync гарантирует, что данные на диске всегда будут в актуальном состоянии, минимизируя риск их потери в случае сбоя системы. Однако это может замедлять операции записи.

WAL (Write-Ahead Logging): Это механизм, при котором все изменения данных сначала записываются в журнал транзакций (WAL), прежде чем они будут применены к основной базе данных. WAL позволяет восстановить данные в случае сбоя, даже если записи в основной базе еще не завершены. Контрольные точки (checkpoints) регулярно сбрасывают содержимое WAL в основной файл данных, уменьшая его размер. Это помогает быстро восстанавливать систему после сбоев, но для полноценной работы WAL необходимо, чтобы эти записи действительно были записаны на диск.

fsync: без этого параметра PostgreSQL не проверяет, были ли данные из журнала WAL на самом деле записаны на диск, прежде чем подтвердить транзакцию. Если fsync отключен, данные могут "зависнуть" в кэшах операционной системы или на уровне аппаратного кэша жесткого диска. Это означает, что в случае аварийного отключения питания или сбоя ОС, данные из WAL могут не быть записаны на диск, что приводит к потере данных, несмотря на механизм WAL.